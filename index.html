
<meta content="charset=utf-8" http-equiv="Content-Type"/>

<html>
<head>
  <script src="underscore-min.js"></script>
  <script src="twgl-full.min.js"></script>
  <script src="levels/levels.js"></script>
  <script src="collisions.js"></script>
  <script src="terrain.js"></script>
  <script src="level.js"></script>
  <script src="ball.js"></script>
</head>
<body>

<script id="default-vs" type="x-shader/v-shader">
  attribute vec3 position;
  uniform mat4 u_projection;
  uniform mat4 u_world;
  uniform mat4 u_view;
  varying float v_height;

  void main() {
    v_height = position[1] / 10.0;
    gl_Position = u_projection*u_view*u_world*vec4(position, 1.0);
  }
</script>

<script id="default-fs" type="x-shader/f-shader">
  precision mediump float;
  varying float v_height;
  uniform vec4 u_color;

  void main() {
    gl_FragColor = u_color * v_height;
  }
</script>

<style>
  body { margin: 0px }
  canvas { width: 100%; height: 100%; }
  #watermeter { position: absolute; top: 0px; }
  #reset-level { position: absolute; bottom: 0;}
  .overlay {
    width: 60%;
    height: 60%;
    background-color: white;
    position: absolute;
    top: 20%; left: 20%;
    display: none;
  }
  #complete.last button {
    display: none;
  }
  .visible {
    display: block;
  }
</style>
  <progress id="watermeter" value="100"></progress>
  <canvas id="canvas"></canvas>
  <div id="complete" class="overlay">
    <strong>Level Complete!</strong>
    <button id="next-level" type="button">Next Level</button>
  </div>
  <button id="reset-level" type="button">Reset</button>
</body>
<script>
  Level.load(levels);

  var v3 = twgl.v3, m4 = twgl.m4;
  var gl = twgl.getWebGLContext(canvas);
  var defaultProgramInfo = twgl.createProgramInfo(gl, ["default-vs", "default-fs"]);
  var sphereBufferInfo = twgl.primitives.createSphereBufferInfo(gl, 1.0, 12, 8);

  var GRAVITY = v3.create(0, -0.01, 0);

  var levelIndex = 1;
  var level, balls, terrain;
  var terrainLookups, waterLookups, terrainBufferInfo, waterBufferInfo;
  var completeTriggered;

  startLevel(levelIndex);
  
  // Capturing DOM events because we need render context to actually handle
  var mouseX = 0, mouseY = 0;
  canvas.onmousemove = function(e) {
    mouseX = e.clientX;
    mouseY = e.clientY;
  };

  var reset = document.getElementById('reset-level');
  var next = document.getElementById('next-level');

  reset.onclick = function () { startLevel(levelIndex); };
  next.onclick = function () { startLevel(++levelIndex); };

  var keys = { };
  document.onkeydown = function(e) { keys[e.keyCode] = true; };
  document.onkeyup = function(e) { delete keys[e.keyCode]; };

  var mouseDown = false, mouseEvent = false, dblClick = false;
  document.onmousedown = function(e) { mouseEvent = true; mouseDown = true; };
  document.onmouseup = function(e) { mouseEvent = true; mouseDown = false; };
  document.ondblclick = function(e) { dblClick = true; };

  function render() {
    if (level.complete && !completeTriggered) {
      completeLevel(levelIndex);
    }

    twgl.resizeCanvasToDisplaySize(gl.canvas);
    var width = gl.canvas.width, height = gl.canvas.height;
    var aspect = width/height, frustum = level.width * 2.5;
    gl.viewport(0, 0, width, height);

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.DEPTH_TEST);
   
    var target = level.target;
    var eye = level.eye;
    var up = v3.create(0, 1, 0);

    var invview = m4.lookAt(eye, target, up);
    var view = m4.inverse(invview);
    var world = m4.create();
    var projection = m4.ortho(-aspect*frustum, aspect*frustum, -frustum, frustum, 1, 1000);
    var invproj = m4.inverse(projection);

    var screenNear = screenToWorld(mouseX, mouseY, invproj, invview, 0);
    var screenFar = screenToWorld(mouseX, mouseY, invproj, invview, 1);
    var direction = v3.normalize(v3.subtract(screenFar, screenNear));

    // Compute cardinal directions for camera motion: up, right, down, left
    var cardinalUp = v3.subtract(target, eye);
    cardinalUp[1] = 0;
    var cardinals = [v3.normalize(cardinalUp, cardinalUp)];
    for (var i = 0; i < 3; i++) {
      cardinals.push(m4.transformPoint(rotate90Y, cardinals[i]));
    }

    var hoverBall = null;
    checkInterballCollisions(balls);
    _.each(balls, function(ball, i) {
      // Control the active ball with keys
      if (ball == level.ball) ball.controlFixed(keys, cardinals);

      // Accelerate with gravity
      if (!ball.contact) {
        v3.add(ball.velocity, GRAVITY, ball.velocity);
      }

      // Soak up water from water layers
      _.each(waterLookups, function(lookup) {
        if (lookup.waterRemain <= 0) return;
        var collision = lookup.collide(ball.position,
          ball.radius, ball.position[1] - ball.radius);
        if (collision) {
          var waterRemain = lookup.waterRemain;
          var absorption = Math.min(0.5*waterRemain, 0.01);
          if (waterRemain < 0.001) absorption = waterRemain;
          lookup.waterRemain -= absorption;
          ///ball.grow(absorption);
        }
      });

      // Check what the mouse is hovering over
      var collide = collideLine(ball.position, ball.radius, screenNear, direction);
      if (collide) {
        hoverBall = ball;
        if (dblClick) {
          level.addBall(ball.split());
        } else if (mouseEvent && mouseDown) {
          level.activateBall(i);
        }
      }

      // Update physics
      ball.update();
      checkLookupXZContact(terrainLookups, ball);

    });

    level.update();

    // Render all balls
    var uniforms = { u_projection: projection, u_view: view };
    gl.useProgram(defaultProgramInfo.program);
    twgl.setBuffersAndAttributes(gl, defaultProgramInfo, sphereBufferInfo);
    _.each(balls, function(ball) {
      ball.getWorld(world);
      var alpha = (ball == hoverBall) ? 1.0 : 0.5;
      
      uniforms.u_world = world;
      uniforms.u_color = [0.0, 1.0, 0.5, alpha];
      twgl.setUniforms(defaultProgramInfo, uniforms);
      twgl.drawBufferInfo(gl, gl.TRIANGLES, sphereBufferInfo);
    });

    _.each(level.goals, function (goal) {
      level.getGoalWorld(world, goal);
      uniforms.u_world = world;
      uniforms.u_color = [1.0, 0.2, 0.2, 1.0];
      twgl.setUniforms(defaultProgramInfo, uniforms);
      twgl.drawBufferInfo(gl, gl.TRIANGLES, sphereBufferInfo);
    });

    twgl.setBuffersAndAttributes(gl, defaultProgramInfo, terrainBufferInfo);
    uniforms.u_color = [0.6, 0.6, 0.0, 1.0];
    uniforms.u_world = m4.create();
    twgl.setUniforms(defaultProgramInfo, uniforms);
    twgl.drawBufferInfo(gl, gl.TRIANGLES, terrainBufferInfo);

    twgl.setBuffersAndAttributes(gl, defaultProgramInfo, waterBufferInfo);
    uniforms.u_color = [0.0, 0.2, 0.6, 1.0];
    twgl.setUniforms(defaultProgramInfo, uniforms);
    twgl.drawBufferInfo(gl, gl.TRIANGLES, waterBufferInfo);

    requestAnimationFrame(render);
    mouseEvent = false;
    dblClick = false;
  }

  function screenToWorld(x, y, invproj, invview, z) {
    var width = canvas.width, height = canvas.height;
    var dx = 2*mouseX/width - 1;
    var dy = 1 - 2*mouseY/height;
    z = z || 0;
    return m4.transformPoint(invview, m4.transformPoint(invproj, [dx, dy, z]));
  }

  function completeLevel (levelIndex) {
    var complete = document.getElementById('complete');
    complete.classList.add('visible');

    if (levelIndex === Level.list.length - 1)
      complete.classList.add('last');

    completeTriggered = true;
    console.log('Level Complete!');
  }

  function startLevel (levelIndex) {
    var complete = document.getElementById('complete');
    complete.classList.remove('visible');
    complete.classList.remove('last');

    level = Level.get(levelIndex);
    level.reset();
    terrain = level.terrain;
    terrainBufferInfo = terrain.createTerrainBufferInfo(gl);
    waterBufferInfo = terrain.createWaterBufferInfo(gl);

    terrainLookups = _.map(terrain.platforms, function(p) {
      return new TriangleLookupXZ(p.vertices, p.bottom, p.thickness);
    });

    waterLookups = _.map(terrain.platforms, function(p) {
      var result = new TriangleLookupXZ(p.waterVertices, p.bottom, p.thickness);
      result.waterRemain = result.waterTotal = p.thickness * p.waterVertices.length / 6;
      return result;
    });

    balls = level.balls;

    completeTriggered = false;
  }

  render();
</script>
</html>

