
<meta content="charset=utf-8" http-equiv="Content-Type"/>

<html>
<head>
  <script src="underscore-min.js"></script>
  <script src="twgl-full.min.js"></script>
  <script src="levels/levels.js"></script>
  <script src="collisions.js"></script>
  <script src="terrain.js"></script>
  <script src="level.js"></script>
  <script src="ball.js"></script>
</head>
<body>

<script id="default-vs" type="x-shader/v-shader">
  attribute vec3 position;
  uniform mat4 u_projection;
  uniform mat4 u_world;
  uniform mat4 u_view;
  varying float v_height;

  void main() {
    v_height = position[1] / 10.0;
    gl_Position = u_projection*u_view*u_world*vec4(position, 1.0);
  }
</script>

<script id="default-fs" type="x-shader/f-shader">
  precision mediump float;
  varying float v_height;
  uniform vec4 u_color;

  void main() {
    gl_FragColor = u_color * v_height;
  }
</script>

<style>
  body { margin: 0px }
  canvas { width: 100%; height: 100%; }
  #watermeter { position: absolute; top: 0px; }
</style>
  <progress id="watermeter" value="100"></progress>
  <canvas id="canvas"></canvas>
</body>
<script>
  Level.load(levels);

  var v3 = twgl.v3, m4 = twgl.m4;
  var gl = twgl.getWebGLContext(canvas);
  var defaultProgramInfo = twgl.createProgramInfo(gl, ["default-vs", "default-fs"]);
  var sphereBufferInfo = twgl.primitives.createSphereBufferInfo(gl, 1.0, 12, 8);

  var level = Level.get(1);

  var terrain = level.terrain;
  var terrainBufferInfo = terrain.createTerrainBufferInfo(gl);

  var platform0 = terrain.platforms[0];
  var lookups = _.map(terrain.platforms, function(p) {
    return new TriangleLookupXZ(p.vertices, p.bottom, p.thickness);
  });

  var GRAVITY = v3.create(0, -0.01, 0);
  
  // Capturing DOM events because we need render context to actually handle
  var mouseX = 0, mouseY = 0;
  canvas.onmousemove = function(e) {
    mouseX = e.clientX;
    mouseY = e.clientY;
  };

  var keys = { };
  document.onkeydown = function(e) { keys[e.keyCode] = true; };
  document.onkeyup = function(e) { delete keys[e.keyCode]; };

  var mouseDown = false, mouseEvent = false, dblClick = false;
  document.onmousedown = function(e) { mouseEvent = true; mouseDown = true; };
  document.onmouseup = function(e) { mouseEvent = true; mouseDown = false; };
  document.ondblclick = function(e) { dblClick = true; };

  function screenToWorld(x, y, invproj, invview, z) {
    var width = canvas.width, height = canvas.height;
    var dx = 2*mouseX/width - 1;
    var dy = 1 - 2*mouseY/height;
    z = z || 0;
    return m4.transformPoint(invview, m4.transformPoint(invproj, [dx, dy, z]));
  }

  var balls = level.balls;
  level.addBall([10, 10], 1.0);

  function render() {
    twgl.resizeCanvasToDisplaySize(gl.canvas);
    var width = gl.canvas.width, height = gl.canvas.height;
    var aspect = width/height, frustum = level.width * 2.5;
    gl.viewport(0, 0, width, height);

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.DEPTH_TEST);
   
    var target = level.target;
    var eye = level.eye;
    var up = v3.create(0, 1, 0);

    var invview = m4.lookAt(eye, target, up);
    var view = m4.inverse(invview);
    var world = m4.create();
    var projection = m4.ortho(-aspect*frustum, aspect*frustum, -frustum, frustum, 1, 1000);
    var invproj = m4.inverse(projection);

    var screenNear = screenToWorld(mouseX, mouseY, invproj, invview, 0);
    var screenFar = screenToWorld(mouseX, mouseY, invproj, invview, 1);
    var direction = v3.normalize(v3.subtract(screenFar, screenNear));

    var hoverBall = null;
    checkInterballCollisions(balls);
    _.each(balls, function(ball, i) {
      // Accelerate with gravity
      if (!ball.contact) {
        v3.add(ball.velocity, GRAVITY, ball.velocity);
      }

      // Control the active ball with keys
      if (ball == level.ball) ball.control(keys);

      // Check what the mouse is hovering over
      var collide = collideLine(ball.position, ball.radius, screenNear, direction);
      if (collide) {
        hoverBall = ball;
        if (dblClick) {
          level.addBall(ball.split());
        } else if (mouseEvent && mouseDown) {
          level.activateBall(i);
        }
      }

      // Update physics
      ball.update();
      checkLookupXZContact(lookups, ball);
    });

    // Render all balls
    var uniforms = { u_projection: projection, u_view: view };
    gl.useProgram(defaultProgramInfo.program);
    twgl.setBuffersAndAttributes(gl, defaultProgramInfo, sphereBufferInfo);
    _.each(balls, function(ball) {
      ball.getWorld(world);
      var alpha = (ball == hoverBall) ? 1.0 : 0.5;
      
      uniforms.u_world = world;
      uniforms.u_color = [0.0, 1.0, 0.5, alpha];
      twgl.setUniforms(defaultProgramInfo, uniforms);
      twgl.drawBufferInfo(gl, gl.TRIANGLES, sphereBufferInfo);
    });

    _.each(level.goals, function (goal) {
      level.getGoalWorld(world, goal);
      uniforms.u_world = world;
      uniforms.u_color = [1.0, 0.2, 0.2, 1.0];
      twgl.setUniforms(defaultProgramInfo, uniforms);
      twgl.drawBufferInfo(gl, gl.TRIANGLES, sphereBufferInfo);
    });

    twgl.setBuffersAndAttributes(gl, defaultProgramInfo, terrainBufferInfo);
    uniforms.u_color = [0.6, 0.6, 0.0, 1.0];
    uniforms.u_world = m4.create();
    twgl.setUniforms(defaultProgramInfo, uniforms);
    twgl.drawBufferInfo(gl, gl.TRIANGLES, terrainBufferInfo);

    requestAnimationFrame(render);
    mouseEvent = false;
    dblClick = false;
  }

  render();
</script>
</html>

